<!DOCTYPE html>
<html>
<head>
    <title>HSF Calculator</title>
    <style>
        body { font-family: monospace; margin: 20px; }
        pre { white-space: pre-wrap; }
        button { margin: 10px 0; padding: 5px 10px; }
    </style>
</head>
<body>
    <h1>Heliobiology Solar Function Calculator 0.05</h1>
    <button onclick="loadData()">Load Latest SRS Data</button>
    <div>
        <pre id="output">Click the button above to load data...</pre>
    </div>

    <script>
        async function loadData() {
            try {
                document.getElementById('output').textContent = 'Loading...';
                const response = await fetch('https://services.swpc.noaa.gov/text/solar-regions.txt');
                const text = await response.text();
								console.log('Raw SRS data:', text); 
                const result = processData(text);
                document.getElementById('output').textContent = result;
            } catch (error) {
                document.getElementById('output').textContent = 'Error loading data: ' + error.message;
            }
        }

 function processData(text) {
    // Extract the header and find where region data starts
    const lines = text.split('\n');
    const regionStartIndex = lines.findIndex(line => 
        line.trim().match(/^\d+\s+[NS]\d+[EW]\d+/)
    );
    
    if (regionStartIndex === -1) {
        console.log('Debug: Could not find start of region data');
        console.log('First few lines:', lines.slice(0, 10).join('\n'));
        return 'Could not parse SRS data format.';
    }

    // Format the output with original header
    let output = lines.slice(0, regionStartIndex).join('\n') + '\n';
    
    // Process each region line
    for (let i = regionStartIndex; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line || line.startsWith('IA.')) break;
        
        // Try to parse the region data
        try {
            const region = parseRegionLine(line);
            const hsf = calculateHelioscreamFactor(region);
            
            // Add the original line plus HSF
            output += `${line} | HSF: ${hsf.points.toString().padStart(2, '0')} (${hsf.percentage}%) - ${hsf.category}\n`;
        } catch (e) {
            console.log('Parsing error for line:', line);
            console.log('Error:', e);
            // If parsing fails, just include the original line
            output += line + '\n';
        }
    }
    
    return output;
}

function parseRegionLine(line) {
    // Remove any weird characters
    line = line.replace(/^[â€“-]\s*/, '');
    
    const parts = line.trim().split(/\s+/);
    
    // Ensure we have enough parts
    if (parts.length < 7) {
        throw new Error('Insufficient line data: ' + line);
    }
    
    const locationMatch = parts[1].match(/([NS])(\d+)([EW])(\d+)/);
    
    return {
        number: parts[0],
        location: parts[1],
        hemisphere: locationMatch ? locationMatch[1] : '',
        latitude: locationMatch ? parseInt(locationMatch[2]) : 0,
        direction: locationMatch ? locationMatch[3] : '',
        const locationMatch = parts[1].match(/([NS])(\d+)([EW])(\d+)/);
	longitude: locationMatch ? parseInt(locationMatch[4]) : 0,
        carrington: parseInt(parts[2]),
        area: parseInt(parts[3]),
        classification: parts[5],
        spotCount: parseInt(parts[6]),
        magneticType: parts[7] || 'A'
    };
}
        function calculateHelioscreamFactor(region) {
    let points = 0;
    
    // 1. Magnetic classification
    if (region.magneticType.includes('Alpha')) {
        points += 1;
    } else if (region.magneticType.includes('Beta-Gamma-Delta')) {
        points += 15;
    } else if (region.magneticType.includes('Beta-Gamma')) {
        points += 9;
    } else if (region.magneticType.includes('Beta-Delta')) {
        points += 6;
    } else if (region.magneticType.includes('Beta')) {
        points += 3;
    }
    
    // 2. Spot classification
    const spotClass = region.classification.charAt(0);
    if (['D', 'E', 'F'].includes(spotClass)) {
        points += 5;
    } else if (spotClass === 'C') {
        points += 3;
    } else {
        points += 1;
    }
    
    // 3. Position relative to central meridian
    points += calculateCentralMeridianPoints(region.longitude);
    
    // 4. Area size
    const area = region.area;
    if (area > 200) {
        points += 7;
    } else if (area > 100) {
        points += 5;
    } else if (area >= 50) {
        points += 3;
    } else {
        points += 1;
    }
    
    // 5. Sunspot count
    const spotCount = region.spotCount;
    if (spotCount >= 16) {
        points += 7;
    } else if (spotCount >= 9) {
        points += 5;
    } else if (spotCount >= 4) {
        points += 3;
    } else {
        points += 1;
    }
    
    // Calculate percentage
    const percentage = (points / 44) * 100;
    
    // Determine risk category
    let category;
    if (percentage <= 25) {
        category = 'Low';
    } else if (percentage <= 50) {
        category = 'Moderate';
    } else if (percentage <= 75) {
        category = 'High';
    } else {
        category = 'Extreme';
    }
    
    return {
        points,
        percentage: percentage.toFixed(1),
        category
    };
}

function calculateCentralMeridianPoints(longitude) {
    console.log('Longitude input:', longitude);
    const absLong = Math.abs(longitude);
    console.log('Absolute longitude:', absLong);
    
    if (absLong <= 15) {
        return 10;  // Central
    } else if (absLong <= 30) {
        return 7;   // Near-central
    } else if (absLong <= 60) {
        return 3;   // Limb
    } else {
        return 1;   // Far limb
    }
}
	    
    </script>
</body>
</html>
